# Identification
### MorseCode App
#### CSCI 4176 Mobile Computing Project (Fall 2018)
Group 16:
* Dinesh Sai Bayireddi   B00791584
* George Faraj           B00638341
* Paul Duchesne          B00332119
* Samarth Raval          B00812673
* Tom Smith              B00694293

For questions about this project send an email to [Paul](mailto:paulduchesne1337@gmail.com).

This project used GitHub for version control and can be accessed [here](https://github.com/PJDuchesne/MorseCode). The only marker with a Github account is listed below.
* Abhishek Kumar Singh (ab649582@dal.ca)

# Project Summary

The main concept behind this application is to provide a method for users to better understand Morse code.
The key features of this application are: allowing the user to translate text to Morse code, allowing the user to translate Morse code to text, and follow a set series of lessons to learn Morse code.
The progress of the aforementioned lessons can be tracked if the user makes an account (another key feature of the application).
Lessons work by introducing text and the Morse code translation the user must tap in to proceed.
Currently there are 10 lessons of increasing difficulty.
The application's UI was designed to not include the default action bar as it was clunky and took away from the user experience.
The UI design combined with the methods for freestyle input and translation were intended to encourage a certain level of immersion to help the user's learning experience.

## Libraries
**Components/Widget Libraries (Button,TextView,ListView,ProgressBar ...):** This project makes use of several components and widgets native to Android.
The code for interacting with these components were a result of what was learned in the CSCI 4176 labs and prior experience with Android application development.

**camera2/CameraManager:** The CameraManager is part of the hardware library native to Android and was used to generate visual feedback via the front facing flashlight most Android devices have. This was achieved with the setTorchMode function, source [here.](https://developer.android.com/reference/android/hardware/camera2/CameraManager)

**Vibrator:** The vibrator class is part of the OS library native to Android it was used to generate haptic feedback. This was achieved with the vibrate and cancel functions, source [here.](https://developer.android.com/reference/android/os/Vibrator)

**FirebaseUser, FirebaseAuth, FirebaseDatabase:** This project used Google's Firebase to handle user account creation and access, as well as storage of user information.
Each FirebaseUser contains a unique key generated by the API which points to a object in the database containing a set of key value pairs.
While not the most efficient method of storing the data generated by the application, the API's documentation and a group member's prior experience with the Firebase library greatly reduced development time which was the most limiting factor in this project.
The tutorial used for references can be found [here](https://firebase.google.com/docs/android/setup).

**ArrayList:** The ArrayList data structure is native to Java. It was used to build arrays of Strings in conjunction with ListViews' and GridViews' .setArrayAdapter functions to populate the screen with data and display it to the user.
The code for utilizing this library was intuitive and did not require external sourcing.

## Installation Notes
This version of the application will run on the same version/settings of the emulator used in the CSCI 4176 Labs. There have been adjustments to the gradle file to include foreign libraries and the Build Tools version 28.0.3 is needed but the compiler will handle these installations, if needed, at the users request.
When testing the application please use a real phone. This is due to the emulator introducing a latency between inputs which heavily interferes with the Morse code input functionality.
Furthermore, the vibration and flash components work and have been tested on several physical devices.
However, the android studio emulator does not have anyway of outputting if the phone's light is on/off or if the device is/isn't vibrating.


## Code Examples

**Problem 1: Morse Code Output Delay Issue**

While attempting to perform morse code output, issues were found when attempting to use the builtin
Java Sleep and thread functions in order to add timing delays between symbol outputs. Due to the
time sensitive nature of Morse code output, the delays had to be explicitly controlled, while
updating the necessary textViews to keep the user visually informed. With the default Sleep
functions, the haptic/audio/light feedback would be properly triggered, but the required textViews
would not be updated due to how multithreading is implemented in Java.

In order to fix this, a recursive function was written to schedule tasks in the future and avoid
blocking the class while the output was being performed. With this solution, it was possible to not
only update the textViews properly, but also allow API to turn off output mid-transmission. This
API is required to allow a smoother user experience.

Below is the relevant code, with proper comments explaining the solution in detail. The full
context of this code can be found in the MorseBrain class.

```
private void TailChain() {
    // Check for end of character and iterate to next character index if necessary
    if (OutputMorseIdx >= CurrentMorseOutput.length()) {
        OutputCharIdx++;
        OutputMorseIdx = 0; // Reset morse index

        // Temporarily blank morse text view as the character switches
        morseTextView.setText(" "); // Char Text view stays the same to give the user continuity

        // Check for end of word and iterate to next word index if necessary
        if (OutputCharIdx >= TokenizedOutput[OutputWordIdx].length()) {
            OutputWordIdx++;
            OutputCharIdx = 0; // Reset char index

            // Check for end of words and return if finished
            if (OutputWordIdx >= TokenizedOutput.length) return;

            // Update text view
            overallTextView.setText(TokenizedOutput[OutputWordIdx]);

            // Add delay between words and return to allow it to run
            delayHandler2.postDelayed(new Runnable(){
                @Override
                public void run(){
                String currentCharString = TokenizedOutput[OutputWordIdx].substring(OutputCharIdx, OutputCharIdx + 1);
                CurrentMorseOutput = GiveLetterGetMorse(currentCharString);

                charTextView.setText(currentCharString);
                morseTextView.setText(CurrentMorseOutput);

                TailChain();
                }
            }, 7*timeUnit); // Delay between words is 7 time units
            return;
        }
        else {
            // Add delay between characters and return to allow it to run
            delayHandler2.postDelayed(new Runnable(){
                @Override
                public void run(){
                    String currentCharString = TokenizedOutput[OutputWordIdx].substring(OutputCharIdx, OutputCharIdx + 1);
                    CurrentMorseOutput = GiveLetterGetMorse(currentCharString);

                    charTextView.setText(currentCharString);
                    morseTextView.setText(CurrentMorseOutput);

                    TailChain();
                }
            }, 3*timeUnit); // Delay between characters is 3 time units
            return;
        }
    }

    feedbackDriver.on();
    delayHandler1.postDelayed(new Runnable(){
        @Override
        public void run(){
            // Turn off feedback
            feedbackDriver.off();

            // Set delay function to start next character after a time unit of silence
            delayHandler2.postDelayed(new Runnable(){
                @Override
                public void run(){
                    OutputMorseIdx++;

                    TailChain();
                }
            }, timeUnit); // Delay between dots & dashes within a character is 1 time unit
        }
    }, ((CurrentMorseOutput.charAt(OutputMorseIdx) == '-') ? 3 : 1)*timeUnit);
}
```

**Problem 2: Using Custom Made Sounds With Varying Frequency**

Since outputting sound from a static MP3/WAV file limits user freedom, the AudioTrack library was used to generate tones of varying frequencies.
Despite the online documentation provided by android on this library it's usage was tricky as it required generating an array of bytes that represent sound waves.
To make up for lack of experience with generating such a structure an online tutorial for creating an 8-bit music generating app was followed (link below).
The generateSound function (shown below) from the tutorial solved the problem with using AudioTrack.
```
private void generateSound(int frequency, int duration) {
    int sampleRate = 44100;
    soundData = new byte[sampleRate * duration];
    for (int i = 0; i < soundData.length; i++) {
        byte sample = (byte) ( Math.sin(2 * Math.PI * frequency * i / sampleRate) * 255 );
        soundData[i] = sample;
    }
}
// Source: Progur.com How to Create 8-bit Music on Android [1]
```

**Problem 3: Checking if the Mobile Device has a Flash Camera**

While using the flashlight of the mobile device was as simple as calling setTorchMode function of the CameraManager class as specified by the android documentation (sourced below) it would cause the emulator to crash.
The reason for this was not identified for a long time. It turned out that the setTorchMode crashes the emulator as the emulator does not have the resources for a flashlight.
This was made known thanks to a StackOverflow post (sourced below) which indicated a method of checking system features (modified and shown below) as well as documentation for checking other device features (also sourced below).

```
//This demonstrates the use of a boolean check that will essentially indicate if the activity will crash or not if setTorchMode was called.
   if( getApplicationContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA_FLASH) ){
        //It is safe to use setTorchMode
   }
   else{
        //Do not use setTorchMode else the activity will crash
   }

// Source: Android Camera2 Library Documentation [2], StackOverflow Checking Flash Post [3], Android Hardware Features Documentation [4]
```

## Feature Section

**Morse Feedback:** Whenever a user is engaging with an activity requiring Morse input or output the device will generate feedback representing the respective Morse code based on their settings.

The following use case illustrates this:
1. The user goes to the settings page sets a low sound frequency and sets haptic feedback to false.
2. The user goes to the Text to Morse page and enters text and clicks the Generate Morse button.
3. The device will output a sound and flash representing the dots and dash of the respective Morse code.

**Morse Translation:** The application has two translation pages accessible from the landing page. One where the user is provided a button to enter Morse code and they are presented with the textual representation as they type. Another activity is provided where they can enter text and see, hear, or feel the Morse code representation of said text upon clicking the Generate Morse button.


**User Account System:** The application supports the creation of an account with an email address and a password of at least 6 characters.

The following use case illustrates this:
1. A user goes to the login page and registers an account.
2. The user is now logged in and completes lessons 1-3.
3. The user logs out and shuts off the application.
4. Upon restarting the application the user logs in and clicks on the lessons page and will see that lessons 1-3 are marked as completed.

## Final Project Status
Overall the project was a success. While the "Bonus" functionality (outlined below) was not completed, all "Expected" and "Minimum" functionalities were accomplished.
A possible improvement for the application would be to remove Firebase and use a MySQL server to increase database performance. Given the modular nature of the UserInfo class this migration could be done given more time.
Another possible improvement would be to add the option to change the Morse code standard that the user wishes to learn which would require updating the usage of the MorseCodeStandards class and the class itself.

Our original scope of the application's intended functionality is as follows:

#### Minimum Functionality
- Input Morse code as taps and display corresponding text. (Completed)
- Take input text and translate it into Morse code as text, audio, and haptic feedback. (Completed)
- Provide an options page to modify timing parameters for Morse code I/O. (Completed)

#### Expected Functionality
- Training course for learning Morse code (With a minimum of 5 lessons). (Completed)
- User login and corresponding database, which stores basic analytics. (Completed)
- Output Morse code as light using the phone’s flashlight. (Completed)

#### Bonus Functionality
- Advanced account analytics. (Not Implemented)
- Provide an option to input Morse code as light. (Not Implemented)
- Implement two-way Morse Code communication between two phones. (Not Implemented)
- Utilize Google’s audio and visual API to provide audio and visual inputs. (Not Implemented)


## Sources
- When designing specific XML shapes StackOverflow was a useful reference. XML files that used such references include links to these pages.


- The firebase documentation used can be found in the following page: https://firebase.google.com/docs/android/setup
  - Note: while the link doesn't contain all the references used it does intuitively redirect to these pages.


[1] "How to Create 8-bit Music on Android", progur.com, 11 December 2016. [Online]. Available: https://progur.com/2016/12/how-to-create-8-bit-music-on-android.html.

[2] "Android Camera2 Library Documentation", developer.android.com, 6 June 2018. [Online]. Available: https://developer.android.com/reference/android/hardware/camera2/CameraManager

[3] "StackOverflow Checking Flash Post", stackoverflow.com, 12 November 2012. [Online] Available: https://stackoverflow.com/questions/13413938/how-to-check-if-device-has-flash-light-led-android

[4] "Android Hardware Features Documentation", developer.android.com, 20 November 2018. [Online] Available: https://developer.android.com/guide/topics/manifest/uses-feature-element#hw-features

[5] "Morse Code", Wikipedia, 13 November 2018. [Online] Available: https://en.wikipedia.org/wiki/Morse_code
